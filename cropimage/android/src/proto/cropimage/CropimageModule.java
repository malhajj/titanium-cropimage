/**
 * This file was auto-generated by the Titanium Module SDK helper for Android
 * Appcelerator Titanium Mobile
 * Copyright (c) 2009-2010 by Appcelerator, Inc. All Rights Reserved.
 * Licensed under the terms of the Apache Public License
 * Please see the LICENSE included with this distribution for details.
 *
 */
package com.example.crop;

import org.appcelerator.kroll.KrollObject;
import org.appcelerator.kroll.KrollFunction;
import org.appcelerator.kroll.KrollModule;
import org.appcelerator.kroll.KrollDict;
import org.appcelerator.kroll.annotations.Kroll;
import org.appcelerator.kroll.common.Log;
import org.appcelerator.kroll.common.TiConfig;

import org.appcelerator.titanium.TiApplication;
import org.appcelerator.titanium.TiBlob;
import org.appcelerator.titanium.view.TiDrawableReference;
import org.appcelerator.titanium.util.TiActivityResultHandler;
import org.appcelerator.titanium.util.TiActivitySupport;

import com.android.camera.CropImageIntentBuilder;

import android.app.Activity;
import android.content.Intent;
import android.net.Uri;
import android.graphics.Color;

import java.io.File;
import java.nio.file.Files;
import java.lang.Boolean;
import java.lang.Integer;
import java.lang.ClassCastException;
import java.lang.NoSuchMethodException;
import java.lang.IllegalAccessException;
import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.Method;

@Kroll.module(name="Cropimage", id="proto.cropimage")
public class CropimageModule extends KrollModule
{
	// Standard Debugging variables
    private static final String LCAT = "CropimageModule";
    private static final boolean DBG = TiConfig.LOGD;

    /* Keys Constants Values */
    @Kroll.constant public static final String imagePath    = "imagePath";
    @Kroll.constant public static final String onSuccess    = "success";
    @Kroll.constant public static final String onError      = "error";
    @Kroll.constant public static final String message      = "message";

    /* Options */
    private boolean circleCrop      = false;
    private boolean doFaceDetection = false;
    private int     outlineColor    = 0xFF1DB7FF;
    private String  outputFormat    = "JPEG";
    private int     outputQuality   = 100;
    private int     outputX         = 200;
    private int     outputY         = 200;
    private boolean overwrite       = false;
    private boolean quietMode       = true;
    private String  renamePrefix    = "cropped_";
    private boolean scale           = true;
    private boolean scaleUpIfNeeded = true;

    /* I/O Uri */
    private Uri srcFileUri, destFileUri;

    /* Error messages */
    protected class Errors {
        public static final String INVALID_KEY       = "Invalid option key; Please check the supplied options";
        public static final String INVALID_TYPE      = "Invalid option type; Please check the supplied options";
        public static final String MISSING_PATH      = "Path to the source image is missing";
        public static final String MISSING_CALLBACKS = "Callbacks are missing";
        public static final String INVALID_CALLBACKS = "Callbacks are invalid. Please specify valid JavaSript functions";
    }

    /** Default constructor */
    public CropimageModule() { super(); }

    /**
     * Configure the module before using.
     * */
    @Kroll.method public boolean configure(KrollDict options)
    {
        try {
            for (String k : options.keySet()) {
                this.getClass()
                    .getDeclaredMethod("set"+ k.substring(0,1).toUpperCase() + k.substring(1), Object.class)
                    .invoke(this, options.get(k));
            }
        } catch (NoSuchMethodException e) {
            logError(Errors.INVALID_KEY);
            return false;
        } catch (IllegalAccessException e) {
            logError(Errors.INVALID_KEY);
            return false;
        } catch (InvocationTargetException e) {
            /* Come from a ClassCastException in the setters */
            logError(Errors.INVALID_TYPE);
            return false;
        }
        return true;
    }

    /**
     * Use to crop an image selected.
     * Returns are processed via callbacks that handle a single object
     * @param options Handle all options and data supplied to the function.
     *      Expected options :
     *          imagePath   - str       : Path to the image to crop
     *          success     - function  : Success callback
     *          error       - function  : Error callback
     * */
    @Kroll.method public void cropImage(KrollDict options)
    {
        /* Check if the path is there */
        if (quietMode && !(options.containsKey(imagePath))) {
            logError(Errors.MISSING_PATH);
            return;
        }
        String srcFileUrl = options.get(imagePath).toString();

        /* Be sure that callbacks exist and are valid KrollFunction */
        if (quietMode && !(options.containsKey(onSuccess) && options.containsKey(onError))) {
            logError(Errors.MISSING_CALLBACKS);
            return;
        }

        KrollFunction success, error;
        try {
            success = (KrollFunction) options.get(onSuccess);
            error = (KrollFunction) options.get(onError);
        } catch (ClassCastException e) {
            if(!quietMode) throw e;
            logError(Errors.INVALID_CALLBACKS);
            return;
        }
        CropResultHandler cropResultHandler = new CropResultHandler(success, error);

        try {
            if(DBG) Log.d(LCAT, "Starting cropImage");

            /* Define the output URI*/
            srcFileUri = Uri.parse(srcFileUrl);
            destFileUri = srcFileUri;
            if (!overwrite) {
                String filename = ( new File(srcFileUri.toString()) ).getName();
                destFileUri = Uri.parse(srcFileUrl.replaceFirst(filename, renamePrefix + filename));
            }

            if(DBG) {
                Log.d(LCAT, "Source file : " + srcFileUri.toString());
                Log.d(LCAT, "Destination file : " + destFileUri.toString());
            }

            /* Initialize the intent for the crop activity */
            CropImageIntentBuilder intentBuilder = new CropImageIntentBuilder(outputX, outputY, outputX, outputY, destFileUri);
            intentBuilder.setSourceImage(srcFileUri);
            intentBuilder.setOutlineColor(outlineColor);
            intentBuilder.setOutlineCircleColor(outlineColor);
            intentBuilder.setCircleCrop(circleCrop);
            intentBuilder.setScale(scale);
            intentBuilder.setScaleUpIfNeeded(scaleUpIfNeeded);
            intentBuilder.setDoFaceDetection(doFaceDetection);
            intentBuilder.setOutputFormat(outputFormat);
            intentBuilder.setOutputQuality(outputQuality);
            if(DBG) debugConfig();

            /* Get the current activity and call the intent */
            Activity mainActivity = TiApplication.getAppCurrentActivity();
            TiActivitySupport mainActivitySupport = (TiActivitySupport) mainActivity;
            mainActivitySupport.launchActivityForResult(
                intentBuilder.getIntent(mainActivity),
                mainActivitySupport.getUniqueResultCode(),
                cropResultHandler);

        } catch (Exception e) {
            cropResultHandler.handleError(e);
        }
    }

    protected class CropResultHandler implements TiActivityResultHandler
    {
        private KrollFunction successCallback, errorCallback;
        private KrollDict callbackArgs;

        public CropResultHandler(KrollFunction successCallback, KrollFunction errorCallback)
        {
            this.successCallback  = successCallback;
            this.errorCallback    = errorCallback;
            callbackArgs = new KrollDict();
        }

        public void handleError(Exception e)
        {
            if(DBG) Log.d(LCAT, "An error has occured");
            callbackArgs.put(message, e.getMessage());
            errorCallback.callAsync((KrollObject) errorCallback, callbackArgs);
        }

        public void onError(Activity activity, int requestCode, Exception e)
        {
          handleError(e);
        }

        /* Handle the result, i.e. return the output path. If the action have been canceled, then,
         * the source path is returned */
        public void onResult(Activity activity, int requestCode, int resultCode, Intent data)
        {
            String outputUrl = resultCode == Activity.RESULT_CANCELED ? srcFileUri.toString() : data.getAction();
            callbackArgs.put(imagePath, outputUrl);
            successCallback.callAsync((KrollObject) successCallback, callbackArgs);
        }
    }

    /* Log an error into Titanium's console */
    private void logError (String errorMsg)
    {
      Log.e(LCAT, "\n/!\\ ------------------------ /!\\\n" + errorMsg);
    }

    /* Configuration Setters */
    /** circle crop option setter, expecting a boolean
     * If True, the cropper will be displayed as a circle and the corresponding
     * cropped image will also be a circle
     * @param value The value to set; expecting a boolean.
     * */
    @Kroll.setProperty public void setCircleCrop(Object value) {
        circleCrop = ((Boolean) value).booleanValue();
    }

    /** do face detection  option setter, expecting a boolean
     * If True, the activity will try to identify face in the image and focus the crop
     * selection on faces.
     * @param value The value to set; expecting a boolean.
     * */
    @Kroll.setProperty public void setDoFaceDetection(Object value) {
        doFaceDetection = ((Boolean) value).booleanValue();
    }

    /** outline color option setter, expecting a String, android color .
     * Set the color of the rectangle used during the crop, using android color format.
     * Exemple : #FF1DB7FF
     * @param value The value to set; expecting a string android color.
     * */
    @Kroll.setProperty public void setOutlineColor(Object value) {
        outlineColor = Color.parseColor(value.toString());
    }

    /** output format option setter, expecting a string JPEG, PNG or WEBP
     * Specify the output format of the cropped image
     * @param value The value to set; expecting a string in ('JPEG', 'PNG', 'WEBP')
     * */
    @Kroll.setProperty public void setOutputFormat(Object value) {
        String format = value.toString();
        if (!format.matches("^JPEG|PNG|WEBP$")) throw new IllegalArgumentException();
        outputFormat = format;
    }

    /** output quality option setter, expecting an integer between 0 and 100
     * Only works with JPEG output format to specify the quality of the JPEG
     * 0 = lowest quality, 100 = best quality
     * @param value The value to set; An integer between 0 and 100.
     * */
    @Kroll.setProperty public void setOutputQuality(Object value) {
        int quality = Integer.parseInt(value.toString());
        if (!String.valueOf(quality).matches("^[0-9]{1,2}|100$")) throw new IllegalArgumentException();
        outputQuality = quality;
    }

    /** output x option setter, expencting an integer
     * Specify the width of the expected cropped output.
     * @param value The value to set; expecting an integer.
     * */
    @Kroll.setProperty public void setOutputX(Object value) {
        int x = Integer.parseInt(value.toString());
        if (x <= 0) throw new IllegalArgumentException();
        outputX = x;
    }

    /** output y option setter, expencting an integer
     * Specify the height of the expected cropped output.
     * @param value The value to set; expecting an integer.
     * */
    @Kroll.setProperty public void setOutputY(Object value) {
        int y = Integer.parseInt(value.toString());
        if (y <= 0) throw new IllegalArgumentException();
        outputY = y;
    }

    /** overwrite option setter, expecting a boolean argument;
     * if True, the source image will be overwritten with the cropped one.
     * @param value The value to set; expecting a boolean.
     * */
    @Kroll.setProperty public void setOverwrite(Object value) {
        overwrite = ((Boolean) value).booleanValue();
    }

    /** quietMode option setter, expecting a boolean argument;
     * if True, errors that can't be passed through the error callback might be caught
     * and handled via console error messages, rather than making the app crash
     * @param value The value to set; expecting a boolean value.
     * */
    @Kroll.setProperty public void setQuietMode(Object value) {
        quietMode = ((Boolean) value).booleanValue();
    }

    /** renamePrefix option setter, expecting a String.
     * In case when overwritting is set to false, used to rename the input
     * @param value The value to set; expecting a String value.
     * */
    @Kroll.setProperty public void setRenamePrefix(Object value) {
        renamePrefix = value.toString();
    }

    /** scale  option setter, expecting a boolean
     * If True, scale down the image to fit the cropped output
     * @param value The value to set; expecting a boolean.
     * */
    @Kroll.setProperty public void setScale(Object value) {
        scale = ((Boolean) value).booleanValue();
    }

    /** scale if needed  option setter, expecting a boolean
     * If True, scale up the image to fit the cropped output size
     * @param value The value to set; expecting a boolean.
     * */
    @Kroll.setProperty public void setScaleUpIfNeeded(Object value) {
        scaleUpIfNeeded = ((Boolean) value).booleanValue();
    }

    private void debugConfig() throws Exception {
      System.out.println("============= DEBUG CONFIG ==============");
        for(Method m : this.getClass().getDeclaredMethods()) {
            if (m.getName().matches("^set.*")) {
                String field = m.getName().substring(3,4).toLowerCase() + m.getName().substring(4);
                System.out.println(field + " : " + this.getClass().getDeclaredField(field).get(this).toString());
            }
        }
    }
}
